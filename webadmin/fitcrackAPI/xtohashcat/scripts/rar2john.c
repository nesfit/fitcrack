/*
 * rar2john utility for RAR 3.x files, written in 2011 by Dhiru Kholia for GSoC.
 * rar2john processes input RAR files into a format suitable for use with JtR.
 *
 * This software is Copyright (c) 2011, Dhiru Kholia <dhiru.kholia at gmail.com>
 * and (c) 2012, magnum and (c) 2014, JimF
 * and it is hereby released to the general public under the following terms:
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted.
 *
 * Huge thanks to Marc Bevand <m.bevand (at) gmail.com> for releasing unrarhp
 * (http://www.zorinaq.com/unrarhp/) and documenting the RAR encryption scheme.
 * This patch is made possible by unrarhp's documentation.
 *
 * Usage:
 *
 * 1. Run rar2john on rar file(s) as "rar2john [rar files]".
 *    Output is written to standard output.
 * 2. Run JtR on the output generated by rar2john as "john [output file]".
 *
 * Output Line Format:
 *
 * For type = 0 for files encrypted with "rar -hp ..." option
 * archive_name:$RAR3$*type*hex(salt)*hex(partial-file-contents):type::::archive_name
 *
 * For type = 1 for files encrypted with "rar -p ..." option
 * archive_name:$RAR3$*type*hex(salt)*hex(crc)*PACK_SIZE*UNP_SIZE*0*archive_name*offset-for-ciphertext*method:type::file_name
 *
 * or
 *
 * archive_name:$RAR3$*type*hex(salt)*hex(crc)*PACK_SIZE*UNP_SIZE*1*hex(full encrypted file)*method:type::file_name
 *
 * TODO:
 * Possibly support some file magics (see zip2john)
 *
 * FIXED:
 * Archive starting with a directory is currently not read (skip it)
 * Archive starting with a plaintext file is currently not read (skip it)
 * Pick smallest possible file in case of -p mode, just like pkzip do
 * If any of the files is uncompressed, this is preferred even if larger
 * Add METHOD to output
 *
 * Edited by David Bolvansky (david.bolvansky@gmail.com) and Radek Hranicky (hranicky@fit.vut.cz)
 * Changes: rar2john is now standalone utility, does not require john
 * Last update: 2023-04-14
 */

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>
#include <inttypes.h>



#include "rar2john.h"
#include "base64_convert.h"


/******************************************/
/* here we try to 'find' a usable fseek64 */
/******************************************/
#if SIZEOF_LONG == 8
#define jtr_fseek64 fseek

#elif HAVE_FSEEK64 /* Various */
// int fseek64 (FILE *stream, long long offset, int whence);
#define jtr_fseek64 fseek64

#elif HAVE_FSEEKO64 /* Various */
// int fseeko64 (FILE *stream, long long offset, int whence);
#define jtr_fseek64 fseeko64

#elif defined (HAVE__FSEEKI64) || defined (_MSC_VER) /* Windows */
// int _fseeki64(FILE *stream, __int64 offset, int origin);
#define jtr_fseek64 _fseeki64

#elif SIZEOF_OFF_T == 8 && HAVE_FSEEKO /* Other LLP64 */
// int _fseeko(FILE *stream, __int64 offset, int origin);
#define jtr_fseek64 fseeko

#elif HAVE_LSEEK64 /* Linux 32-bit or X32 */
// off64_t lseek64(int fd, off64_t offset, int whence);
//   !!!WARNING, we may need to flush, if file open for reading
//      for this to work right, especially in SEEK_END mode
#define jtr_fseek64(s,o,w) lseek64(fileno(s),o,w);

#elif SIZEOF_OFF_T == 8 && HAVE_LSEEK /* POSIX.1 */
// off_t lseek(int fildes, off_t offset, int whence);
//   !!!WARNING, we may need to flush, if file open for reading
//      for this to work right, especially in SEEK_END mode
#define jtr_fseek64(s,o,w) lseek(fileno(s),o,w)

#else
// at this point, we have NO easy workaround for a seek64 function.
// we can code things for specific environments, OR simply fall
// back to using fseek (and warn the user)
#if defined (__CYGWIN32__) && !defined (__CYGWIN64__)
   extern  int fseeko64 (FILE* stream, int64_t offset, int whence);
  #define jtr_fseek64 fseeko64
#elif defined (__CYGWIN64__)
   extern  int fseeko (FILE* stream, int64_t offset, int whence);
  #define jtr_fseek64 fseeko
#else
  #if defined(__GNUC__) && defined (AC_BUILT)
    #warning Using 32-bit fseek(). Files larger than 2GB will be handled unreliably
  #endif
  #define jtr_fseek64 fseek
#endif

#endif /* fseek */


/******************************************/
/* here we try to 'find' a usable ftell64 */
/******************************************/
#if SIZEOF_LONG == 8
#define jtr_ftell64 ftell

#elif HAVE_FTELL64 /* Linux and others */
// long long ftell64(FILE *stream)
#define jtr_ftell64 ftell64

#elif HAVE_FTELLO64 /* Solaris */
// integer*8 function ftello64 (lunit) (Solaris)
#define jtr_ftell64 ftello64

#elif defined (HAVE__FTELLI64) || defined (_MSC_VER) /* Windows */
// __int64 _ftelli64(FILE *stream);
#define jtr_ftell64 _ftelli64

#elif SIZEOF_OFF_T == 8 && HAVE_FTELLO /* Other LLP64 */
// off_t ftello(FILE *stream);
#define jtr_ftell64 ftello

#else
// at this point, we have NO easy workaround for a tell64 function.
// we can code things for specific environments, OR simply fall
// back to using ftell (and warn the user)
#if defined (__CYGWIN32__) && !defined (__CYGWIN64__)
   extern  int64_t ftello64 (FILE* stream);
  #define jtr_ftell64 ftello64
#elif defined (__CYGWIN64__)
   extern  int64_t ftello (FILE* stream);
  #define jtr_ftell64 ftello
#else
  #if defined(__GNUC__) && defined (AC_BUILT)
    #warning Using 32-bit ftell(). Files larger than 2GB will be handled unreliably
  #endif
  #define jtr_ftell64 ftell
#endif

#endif /* ftell */

typedef struct
{
	uint32_t h[8];          // SHA256 state
	uint32_t Nl,Nh;         // UNUSED but here to be compatible with oSSL
	unsigned char buffer[64];   // current/building data 'block'. It IS in alignment
	unsigned int num,md_len;    // UNUSED but here to be compatible with oSSL
	unsigned int total;         // number of bytes processed
	int bIs256;                 // if 1 SHA256, else SHA224
} jtr_sha256_ctx;

void jtr_sha256_init(jtr_sha256_ctx *ctx, int bIs256) {
	ctx->total = 0;
	if ((ctx->bIs256 = bIs256)) {
		// SHA-256 IV
		ctx->h[0] = 0x6A09E667;
		ctx->h[1] = 0xBB67AE85;
		ctx->h[2] = 0x3C6EF372;
		ctx->h[3] = 0xA54FF53A;
		ctx->h[4] = 0x510E527F;
		ctx->h[5] = 0x9B05688C;
		ctx->h[6] = 0x1F83D9AB;
		ctx->h[7] = 0x5BE0CD19;
	} else {
		// SHA-224 IV
		ctx->h[0] = 0xC1059ED8;
		ctx->h[1] = 0x367CD507;
		ctx->h[2] = 0x3070DD17;
		ctx->h[3] = 0xF70E5939;
		ctx->h[4] = 0xFFC00B31;
		ctx->h[5] = 0x68581511;
		ctx->h[6] = 0x64F98FA7;
		ctx->h[7] = 0xBEFA4FA4;
	}
}

#define JOHNSWAP(x) __builtin_bswap32((x))
#define JOHNSWAP64(x) __builtin_bswap64((x))

static const unsigned char padding[128] = { 0x80, 0 /* 0,0,0,0.... */ };

// I wish C++ had a good 'known' ror command :( Hopefully the compilers will be nice with this one.
// GCC seems to do a good job of converting into roll, which is 'good' enough.  The rotates are the
// 'wrong' direction (rol(x,32-y) vs ror(x,y)), but that's not is a problem, same cycle count.
#define ROR32(x,n) ((x>>n)|(x<<(32-n)))
#define ROR64(x,n) ((x>>n)|(x<<(64-n)))

// SHA round macros
#define S0(x)     (ROR32(x, 2) ^ ROR32(x,13) ^ ROR32(x,22))
#define S1(x)     (ROR32(x, 6) ^ ROR32(x,11) ^ ROR32(x,25))
#define F0(x,y,z) ((x & y) | (z & (x | y)))
#define F1(x,y,z) (z ^ (x & (y ^ z)))
// Only used in the 'rotation' mixing macros, in rounds 17 to 64.
#define R0(x)     (ROR32(x, 7) ^ ROR32(x,18) ^ (x>>3))
#define R1(x)     (ROR32(x,17) ^ ROR32(x,19) ^ (x>>10))
// the feedback Mixing macro.
#define M(t) (W[t&0xF] += (R1(W[(t-2)&0xF]) + W[(t-7)&0xF] + R0(W[(t-15)&0xF])))

// Here is the macro for each 'round' of sha256.
#define R(a,b,c,d,e,f,g,h,x,K) do{	  \
		tmp = h + S1(e) + F1(e,f,g) + K + x; \
		h = S0(a) + F0(a,b,c) + tmp; \
		d += tmp; \
	}while(0)


void jtr_sha256_hash_block(jtr_sha256_ctx *ctx, const unsigned char data[64], int perform_endian_swap)
{
	uint32_t A, B, C, D, E, F, G, H, tmp, W[16];
#if ARCH_LITTLE_ENDIAN
	int i;
	if (perform_endian_swap) {
		for (i = 0; i < 16; ++i)
			W[i] = JOHNSWAP(*((uint32_t*)&(data[i<<2])));
	} else
#endif
		memcpy(W, data, 16*sizeof(uint32_t));

	// Load state from all prior blocks (or init state)
	A = ctx->h[0];
	B = ctx->h[1];
	C = ctx->h[2];
	D = ctx->h[3];
	E = ctx->h[4];
	F = ctx->h[5];
	G = ctx->h[6];
	H = ctx->h[7];

	R(A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98);
	R(H, A, B, C, D, E, F, G, W[ 1], 0x71374491);
	R(G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF);
	R(F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5);
	R(E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B);
	R(D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1);
	R(C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4);
	R(B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5);
	R(A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98);
	R(H, A, B, C, D, E, F, G, W[ 9], 0x12835B01);
	R(G, H, A, B, C, D, E, F, W[10], 0x243185BE);
	R(F, G, H, A, B, C, D, E, W[11], 0x550C7DC3);
	R(E, F, G, H, A, B, C, D, W[12], 0x72BE5D74);
	R(D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE);
	R(C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7);
	R(B, C, D, E, F, G, H, A, W[15], 0xC19BF174);
	R(A, B, C, D, E, F, G, H, M(16), 0xE49B69C1);
	R(H, A, B, C, D, E, F, G, M(17), 0xEFBE4786);
	R(G, H, A, B, C, D, E, F, M(18), 0x0FC19DC6);
	R(F, G, H, A, B, C, D, E, M(19), 0x240CA1CC);
	R(E, F, G, H, A, B, C, D, M(20), 0x2DE92C6F);
	R(D, E, F, G, H, A, B, C, M(21), 0x4A7484AA);
	R(C, D, E, F, G, H, A, B, M(22), 0x5CB0A9DC);
	R(B, C, D, E, F, G, H, A, M(23), 0x76F988DA);
	R(A, B, C, D, E, F, G, H, M(24), 0x983E5152);
	R(H, A, B, C, D, E, F, G, M(25), 0xA831C66D);
	R(G, H, A, B, C, D, E, F, M(26), 0xB00327C8);
	R(F, G, H, A, B, C, D, E, M(27), 0xBF597FC7);
	R(E, F, G, H, A, B, C, D, M(28), 0xC6E00BF3);
	R(D, E, F, G, H, A, B, C, M(29), 0xD5A79147);
	R(C, D, E, F, G, H, A, B, M(30), 0x06CA6351);
	R(B, C, D, E, F, G, H, A, M(31), 0x14292967);
	R(A, B, C, D, E, F, G, H, M(32), 0x27B70A85);
	R(H, A, B, C, D, E, F, G, M(33), 0x2E1B2138);
	R(G, H, A, B, C, D, E, F, M(34), 0x4D2C6DFC);
	R(F, G, H, A, B, C, D, E, M(35), 0x53380D13);
	R(E, F, G, H, A, B, C, D, M(36), 0x650A7354);
	R(D, E, F, G, H, A, B, C, M(37), 0x766A0ABB);
	R(C, D, E, F, G, H, A, B, M(38), 0x81C2C92E);
	R(B, C, D, E, F, G, H, A, M(39), 0x92722C85);
	R(A, B, C, D, E, F, G, H, M(40), 0xA2BFE8A1);
	R(H, A, B, C, D, E, F, G, M(41), 0xA81A664B);
	R(G, H, A, B, C, D, E, F, M(42), 0xC24B8B70);
	R(F, G, H, A, B, C, D, E, M(43), 0xC76C51A3);
	R(E, F, G, H, A, B, C, D, M(44), 0xD192E819);
	R(D, E, F, G, H, A, B, C, M(45), 0xD6990624);
	R(C, D, E, F, G, H, A, B, M(46), 0xF40E3585);
	R(B, C, D, E, F, G, H, A, M(47), 0x106AA070);
	R(A, B, C, D, E, F, G, H, M(48), 0x19A4C116);
	R(H, A, B, C, D, E, F, G, M(49), 0x1E376C08);
	R(G, H, A, B, C, D, E, F, M(50), 0x2748774C);
	R(F, G, H, A, B, C, D, E, M(51), 0x34B0BCB5);
	R(E, F, G, H, A, B, C, D, M(52), 0x391C0CB3);
	R(D, E, F, G, H, A, B, C, M(53), 0x4ED8AA4A);
	R(C, D, E, F, G, H, A, B, M(54), 0x5B9CCA4F);
	R(B, C, D, E, F, G, H, A, M(55), 0x682E6FF3);
	R(A, B, C, D, E, F, G, H, M(56), 0x748F82EE);
	R(H, A, B, C, D, E, F, G, M(57), 0x78A5636F);
	R(G, H, A, B, C, D, E, F, M(58), 0x84C87814);
	R(F, G, H, A, B, C, D, E, M(59), 0x8CC70208);
	R(E, F, G, H, A, B, C, D, M(60), 0x90BEFFFA);
	R(D, E, F, G, H, A, B, C, M(61), 0xA4506CEB);
	R(C, D, E, F, G, H, A, B, M(62), 0xBEF9A3F7);
	R(B, C, D, E, F, G, H, A, M(63), 0xC67178F2);

	// save state for usage in next block (or result if this was last block)
	ctx->h[0] += A;
	ctx->h[1] += B;
	ctx->h[2] += C;
	ctx->h[3] += D;
	ctx->h[4] += E;
	ctx->h[5] += F;
	ctx->h[6] += G;
	ctx->h[7] += H;
}

void jtr_sha256_update(jtr_sha256_ctx *ctx, const void *_input, int ilenlft)
{
	int left, fill;
	const unsigned char *input;

	if (ilenlft <= 0)
		return;

	input = (const unsigned char*)_input;
	left = ctx->total & 0x3F;
	fill = 0x40 - left;

	ctx->total += ilenlft;

	if (left && ilenlft >= fill)
	{
		memcpy(ctx->buffer + left, input, fill);
		jtr_sha256_hash_block(ctx, ctx->buffer, 1);
		input += fill;
		ilenlft  -= fill;
		left = 0;
	}

	while(ilenlft >= 0x40)
	{
		jtr_sha256_hash_block(ctx, input, 1);
		input += 0x40;
		ilenlft  -= 0x40;
	}

	if (ilenlft > 0)
		memcpy(ctx->buffer + left, input, ilenlft);
}

#if ARCH_LITTLE_ENDIAN
#define OUTBE32(n,b,i) do { (b)[i] = ((n)>>24); (b)[i+1] = ((n)>>16); (b)[i+2] = ((n)>>8); (b)[i+3] = (n); } while(0)
#define OUTBE64(n,b,i) do {	  \
		(b)[(i)]   = (unsigned char) ( (n) >> 56 ); \
		(b)[(i)+1] = (unsigned char) ( (n) >> 48 ); \
		(b)[(i)+2] = (unsigned char) ( (n) >> 40 ); \
		(b)[(i)+3] = (unsigned char) ( (n) >> 32 ); \
		(b)[(i)+4] = (unsigned char) ( (n) >> 24 ); \
		(b)[(i)+5] = (unsigned char) ( (n) >> 16 ); \
		(b)[(i)+6] = (unsigned char) ( (n) >>  8 ); \
		(b)[(i)+7] = (unsigned char) ( (n)       ); \
	} while(0)

#else
#define OUTBE32(n,b,i) *((uint32_t*)&(b[i]))=n
#define OUTBE64(n,b,i) *((uint64_t*)&(b[i]))=n
#endif

#define ARCH_WORD                   long
#define is_aligned(PTR, CNT) ((((ARCH_WORD)(const void *)(PTR))&(CNT-1))==0)

void jtr_sha256_final(void *_output, jtr_sha256_ctx *ctx)
{
	uint32_t last, padcnt;
	uint32_t bits;
	union {
		uint32_t wlen[2];
		unsigned char mlen[8];  // need aligned on sparc
	} m;
	unsigned char *output = (unsigned char*)_output;

	bits = (ctx->total <<  3);
	m.wlen[0] = 0;
#if ARCH_LITTLE_ENDIAN
	m.wlen[1] = JOHNSWAP(bits);
#else
	m.wlen[1] = bits;
#endif

	last = ctx->total & 0x3F;
	padcnt = (last < 56) ? (56 - last) : (120 - last);

	jtr_sha256_update(ctx, (unsigned char *) padding, padcnt);
	jtr_sha256_update(ctx, m.mlen, 8);

	// the SHA2_GENERIC_DO_NOT_BUILD_ALIGNED == 1 is to force build on
	// required aligned systems without doing the alignment checking.
	// it IS faster (about 2.5%), and once the data is properly aligned
	// in the formats, the alignment checking is nore needed any more.
#if ARCH_ALLOWS_UNALIGNED == 1 || SHA2_GENERIC_DO_NOT_BUILD_ALIGNED == 1
	OUTBE32(ctx->h[0], output,  0);
	OUTBE32(ctx->h[1], output,  4);
	OUTBE32(ctx->h[2], output,  8);
	OUTBE32(ctx->h[3], output, 12);
	OUTBE32(ctx->h[4], output, 16);
	OUTBE32(ctx->h[5], output, 20);
	OUTBE32(ctx->h[6], output, 24);
	if (ctx->bIs256)
		OUTBE32(ctx->h[7], output, 28);
#else
	if (is_aligned(output,sizeof(uint32_t))) {
		OUTBE32(ctx->h[0], output,  0);
		OUTBE32(ctx->h[1], output,  4);
		OUTBE32(ctx->h[2], output,  8);
		OUTBE32(ctx->h[3], output, 12);
		OUTBE32(ctx->h[4], output, 16);
		OUTBE32(ctx->h[5], output, 20);
		OUTBE32(ctx->h[6], output, 24);
		if (ctx->bIs256)
			OUTBE32(ctx->h[7], output, 28);
	} else {
		union {
			uint32_t x[8];
			unsigned char c[64];
		} m;
		unsigned char *tmp = m.c;
		OUTBE32(ctx->h[0], tmp,  0);
		OUTBE32(ctx->h[1], tmp,  4);
		OUTBE32(ctx->h[2], tmp,  8);
		OUTBE32(ctx->h[3], tmp, 12);
		OUTBE32(ctx->h[4], tmp, 16);
		OUTBE32(ctx->h[5], tmp, 20);
		OUTBE32(ctx->h[6], tmp, 24);
		if (ctx->bIs256) {
			OUTBE32(ctx->h[7], tmp, 28);
			memcpy(output, tmp, 32);
		} else
			memcpy(output, tmp, 28);
	}
#endif
}


#define SHA256_CTX           jtr_sha256_ctx
#define SHA256_Init(a)       jtr_sha256_init(a,1)
#define SHA256_Update(a,b,c) jtr_sha256_update(a,b,c)
#define SHA256_Final(a,b)    jtr_sha256_final(a,b)

typedef uint32_t UTF32;
typedef uint16_t UTF16;
typedef uint8_t UTF8;

#define CHUNK_SIZE 4096

/* Max file (path) name length, in characters */
#define PATH_BUF_SIZE 256
#define PATH_BUFFER_SIZE 4096
#define LINE_BUFFER_SIZE 0x400
#define ARCH_INDEX(x)                       ((unsigned int)(unsigned char)(x))

static const int halfShift  = 10; /* used for shifting by 10 bits */

static const UTF32 halfBase = 0x0010000UL;
static const UTF32 halfMask = 0x3FFUL;

static const UTF8 firstByteMark[7] = {
	0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC
};

#define UNI_SUR_HIGH_START  (UTF32)0xD800
#define UNI_SUR_HIGH_END    (UTF32)0xDBFF
#define UNI_SUR_LOW_START   (UTF32)0xDC00
#define UNI_SUR_LOW_END     (UTF32)0xDFFF
#define UNI_REPLACEMENT_CHAR (UTF32)0x0000FFFD

const char itoa16[16]  = "0123456789abcdef";

UTF8 *utf16_to_utf8_r(UTF8 *dst, int dst_len, const UTF16 *source)
{
	UTF8 *tpt = dst;
	UTF8 *targetEnd = tpt + dst_len;
	while (*source) {
		UTF32 ch;
		unsigned short bytesToWrite = 0;
		const UTF32 byteMask = 0xBF;
		const UTF32 byteMark = 0x80;

		ch = *source++;
#if !ARCH_LITTLE_ENDIAN
		ch = (ch >> 8) | (UTF16)(ch << 8);
#endif
		/* If we have a surrogate pair, convert to UTF32 first. */
		if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {
			/*
			 * If the 16 bits following the high surrogate are
			 * in the source buffer...
			 */
			if (*source) {
				UTF32 ch2 = *source;
				/* If it's a low surrogate, convert to UTF32. */
				if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {
					ch = ((ch - UNI_SUR_HIGH_START) << halfShift)
						+ (ch2 - UNI_SUR_LOW_START) + halfBase;
					++source;
				}
			}
		}
		/* Figure out how many bytes the result will require */
		if (ch < (UTF32)0x80) {	     bytesToWrite = 1;
		} else if (ch < (UTF32)0x800) {     bytesToWrite = 2;
		} else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;
		} else if (ch < (UTF32)0x110000) {  bytesToWrite = 4;
		} else {			    bytesToWrite = 3;
			ch = UNI_REPLACEMENT_CHAR;
		}

		tpt += bytesToWrite;
		if (tpt > targetEnd) {
			tpt -= bytesToWrite;
			break;
		}
		switch (bytesToWrite) { /* note: everything falls through. */
		case 4: *--tpt = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
		case 3: *--tpt = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
		case 2: *--tpt = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
		case 1: *--tpt =  (UTF8)(ch | firstByteMark[bytesToWrite]);
		}
		tpt += bytesToWrite;
	}
	*tpt = 0;
	return dst;
}

unsigned int strlen16(const UTF16 *str)
{
	unsigned int len = 0;
	while (*str++ != 0)
		len++;
	return len;
}

char *strnzcpy(char *dst, const char *src, int size)
{
	char *dptr;

	if (size < 1)
		return dst;
	dptr = dst;

	while (--size)
		if (!(*dptr++ = *src++))
			return dst;
	*dptr = 0;

	return dst;
}

/* File magics */
#define RAR_OLD_MAGIC      "\x52\x45\x7e\x5e"
#define RAR3_MAGIC         "\x52\x61\x72\x21\x1a\x07\x00"
#define RAR5_MAGIC         "\x52\x61\x72\x21\x1a\x07\x01\x00"
#define RAR_OLD_MAGIC_SIZE (sizeof(RAR_OLD_MAGIC) - 1)
#define RAR3_MAGIC_SIZE    (sizeof(RAR3_MAGIC) - 1)
#define RAR5_MAGIC_SIZE    (sizeof(RAR5_MAGIC) - 1)

static int verbose;
static char *self_name;

static void hexdump(const void *msg, void *x, unsigned int size)
{
	unsigned int i;

	printf("%s : ", (char *)msg);
	for (i=0;i<size;i++)
	{
		printf("%.2x", ((unsigned char*)x)[i]);
		if ( (i%4)==3 )
		printf(" ");
	}
	printf("\n");
}

static int process_file5(const char *archive_name);

static int check_fread(const size_t buf_size, const size_t size,
                       const size_t nmemb)
{
	if (buf_size < size * nmemb) {
		fprintf(stderr, "Error: check_fread(buf_size=\"%Zu\", size=\"%Zu\", nmemb=\"%Zu\")"
				"failed, buf_size is smaller than size * nmemb.\n",
		        buf_size, size, nmemb);
		return 0;
	}
	return 1;
}

/* Derived from unrar's encname.cpp */
static void DecodeFileName(unsigned char *Name, unsigned char *EncName,
                           size_t EncSize, UTF16 *NameW, size_t MaxDecSize)
{
	unsigned char Flags = 0;
	unsigned int FlagBits = 0;
	size_t EncPos = 0, DecPos = 0;
	unsigned char HighByte = EncName[EncPos++];

	MaxDecSize /= sizeof(UTF16);

	while (EncPos < EncSize - 1 && DecPos < MaxDecSize - 1)
	{
		if (FlagBits == 0)
		{
			Flags = EncName[EncPos++];
			FlagBits = 8;
		}
		switch(Flags >> 6)
		{
		case 0:
#if ARCH_LITTLE_ENDIAN
			NameW[DecPos++] = EncName[EncPos++];
#else
			NameW[DecPos++] = EncName[EncPos++] << 8;
#endif
			break;
		case 1:
#if ARCH_LITTLE_ENDIAN
			NameW[DecPos++] = EncName[EncPos++] + (HighByte << 8);
#else
			NameW[DecPos++] = (EncName[EncPos++] << 8) + HighByte;
#endif
			break;
		case 2:
#if ARCH_LITTLE_ENDIAN
			NameW[DecPos++] = EncName[EncPos] +
				(EncName[EncPos+1]<<8);
#else
			NameW[DecPos++] = (EncName[EncPos] << 8) +
				EncName[EncPos+1];
#endif
			EncPos+=2;
			break;
		case 3:
		{
			int Length = EncName[EncPos++];
			if (Length & 0x80)
			{
				unsigned char Correction = EncName[EncPos++];
				for (Length = (Length & 0x7f) + 2;
				     Length>0 && DecPos < MaxDecSize;
				     Length--, DecPos++)
#if ARCH_LITTLE_ENDIAN
					NameW[DecPos] = ((Name[DecPos] +
					  Correction) & 0xff) + (HighByte << 8);
#else
					NameW[DecPos] = (((Name[DecPos] +
					  Correction) & 0xff) << 8) + HighByte;
#endif
			}
			else
				for (Length += 2;
				     Length>0 && DecPos < MaxDecSize;
				     Length--,DecPos++)
#if ARCH_LITTLE_ENDIAN
					NameW[DecPos] = Name[DecPos];
#else
					NameW[DecPos] = Name[DecPos] << 8;
#endif
		}
		break;
		}
		Flags <<= 2;
		FlagBits -= 2;
	}
	NameW[DecPos < MaxDecSize ? DecPos : MaxDecSize - 1] = 0;
}

static void process_file(const char *archive_name)
{
	FILE *fp;
	unsigned char marker_block[RAR3_MAGIC_SIZE];
	unsigned char archive_hdr_block[13];
	unsigned char file_hdr_block[40];
	int i, count, type;
	struct {
		size_t pack;
		size_t unp;
		uint8_t method;
	} bestsize = { SIZE_MAX, SIZE_MAX };
	char *base_aname;
	unsigned char buf[CHUNK_SIZE];
	uint16_t archive_hdr_head_flags, file_hdr_head_flags, head_size;
	unsigned char *pos;
	int diff;
	int found = 0;
	char path[PATH_BUFFER_SIZE];
	char *gecos, *best = NULL;
	size_t best_len = 0;
	int gecos_len = 0;

	gecos = calloc(1, LINE_BUFFER_SIZE);

	strnzcpy(path, archive_name, sizeof(path));
	base_aname = basename(path);
	errno = 0;

	if (!(fp = fopen(archive_name, "rb"))) {
		fprintf(stderr, "! %s: %s\n", archive_name, strerror(errno));
		goto err;
	}
	/* marker block */
	if (fread(marker_block, RAR3_MAGIC_SIZE, 1, fp) != 1) {
		fprintf(stderr, "! %s: Not a RAR file\n", archive_name);
		goto err;
	}

	if (!memcmp(marker_block, RAR_OLD_MAGIC, RAR_OLD_MAGIC_SIZE)) {
		fprintf(stderr, "! %s: Too old RAR file version (pre 1.50), not supported.\n", archive_name);
		goto err;
	}

	if (memcmp(marker_block, RAR3_MAGIC, RAR3_MAGIC_SIZE)) {
		/* Handle SFX archive, find "Rar!" signature */
		if (memcmp(marker_block, "MZ", 2) == 0) {
			/* jump to "Rar!" signature */
			while (!feof(fp)) {
				count = fread(buf, 1, CHUNK_SIZE, fp);
				if (count < RAR3_MAGIC_SIZE)
					break;
				if ((pos = memmem(buf, count, RAR3_MAGIC, RAR3_MAGIC_SIZE))) {
					diff = count - (pos - buf);
					jtr_fseek64(fp, - diff, SEEK_CUR);
					jtr_fseek64(fp, RAR3_MAGIC_SIZE, SEEK_CUR);
					found = 1;
					break;
				}
				if (feof(fp)) /* We should examine the EOF before seek back */
					break;
				jtr_fseek64(fp, 1 - RAR3_MAGIC_SIZE, SEEK_CUR);
			}
			if (!found) {
				if (process_file5(archive_name))
					return;
				/* The "Not a RAR file" message already printed by process_file5() at this point */
				goto err;
			}
		}
		else {
			/* try to detect RAR 5 files */
			fclose(fp);
			fp = NULL;
			free(best);
			free(gecos);
			if (process_file5(archive_name))
				return;
			fprintf(stderr, "! %s: Not a RAR file\n", archive_name);
			goto err;
		}
	}

	/* archive header block */
	if (fread(archive_hdr_block, 13, 1, fp) != 1) {
		fprintf(stderr, "%s: Error: read failed: %s.\n",
			archive_name, strerror(errno));
		goto err;
	}
	if (archive_hdr_block[2] != 0x73) {
		fprintf(stderr, "%s: Error: archive_hdr_block[2] must be 0x73.\n",
			archive_name);
		goto err;
	}

	/* find encryption mode used (called type in output line format) */
	archive_hdr_head_flags =
	    archive_hdr_block[4] << 8 | archive_hdr_block[3];
	if (archive_hdr_head_flags & 0x0080) {	/* file header block is encrypted */
		type = 0;	/* RAR file was created using -hp flag */
	} else
		type = 1;

	/*
	 * We need to skip ahead, if there is a comment block in the main header.
	 * It causes that header tp be larger that a simple 13 byte block.
	 */
	head_size = archive_hdr_block[6] << 8 | archive_hdr_block[5];
	if (head_size > 13)
		fseek(fp, head_size-13, SEEK_CUR);

next_file_header:
	if (verbose)
		fprintf(stderr, "\n");

	/* file header block */
	count = fread(file_hdr_block, 32, 1, fp);

	if (feof(fp))  {
		if (verbose) {
			fprintf(stderr, "! %s: End of file\n", archive_name);
		}
		goto BailOut;
	}

	if (count != 1) {
		fprintf(stderr, "%s: Error: read failed: %s.\n",
			archive_name, strerror(errno));
		goto err;
	}

	if (type == 1 && file_hdr_block[2] == 0x7a) {
		if (verbose) {
			fprintf(stderr, "! %s: Comment block present?\n", archive_name);
		}
	}
	else if (type == 1 && file_hdr_block[2] != 0x74) {
		fprintf(stderr, "! %s: Not recognising any more headers.\n",
		        archive_name);
		goto BailOut;
	}

	file_hdr_head_flags =
	    file_hdr_block[4] << 8 | file_hdr_block[3];

	/* process -hp mode files
	   use Marc's end-of-archive block decrypt trick */
	if (type == 0) {
		unsigned char buf[24];

		if (verbose) {
			fprintf(stderr, "! -hp mode entry found in %s\n", base_aname);
		}
		printf("%s:$RAR3$*%d*", base_aname, type);
		jtr_fseek64(fp, -24, SEEK_END);
		if (fread(buf, 24, 1, fp) != 1) {
			fprintf(stderr, "%s: Error: read failed: %s.\n",
				archive_name, strerror(errno));
			goto err;
		}

		for (i = 0; i < 8; i++) { /* salt */
			printf("%c%c", itoa16[ARCH_INDEX(buf[i] >> 4)],
			    itoa16[ARCH_INDEX(buf[i] & 0x0f)]);
		}
		printf("*");
		/* encrypted block with known plaintext */
		for (i = 8; i < 24; i++) {
			printf("%c%c", itoa16[ARCH_INDEX(buf[i] >> 4)],
			       itoa16[ARCH_INDEX(buf[i] & 0x0f)]);
		}
		printf(":%d::::%s\n", type, archive_name);
	} else {
		size_t file_hdr_pack_size = 0, file_hdr_unp_size = 0;
		int ext_time_size;
		uint8_t method;
		uint64_t bytes_left;
		uint16_t file_hdr_head_size, file_name_size;
		unsigned char file_name[4 * PATH_BUF_SIZE], file_crc[4];
		unsigned char salt[8] = { 0 };
		unsigned char rejbuf[32];
		char *p;
		unsigned char s;

		if (!(file_hdr_head_flags & 0x8000)) {
			fprintf(stderr, "File header flag 0x8000 unset, bailing out.\n");
			goto BailOut;
		}

		file_hdr_head_size =
		    file_hdr_block[6] << 8 | file_hdr_block[5];

		/*
		 * Low 32 bits.  If header_flags & 0x100 set, then there are additional
		 * 32 bits of length data later in the header. FIXME!
		 */
		file_hdr_pack_size = file_hdr_block[10];
		file_hdr_pack_size <<= 8; file_hdr_pack_size += file_hdr_block[9];
		file_hdr_pack_size <<= 8; file_hdr_pack_size += file_hdr_block[8];
		file_hdr_pack_size <<= 8; file_hdr_pack_size += file_hdr_block[7];

		file_hdr_unp_size = file_hdr_block[14];
		file_hdr_unp_size <<= 8; file_hdr_unp_size += file_hdr_block[13];
		file_hdr_unp_size <<= 8; file_hdr_unp_size += file_hdr_block[12];
		file_hdr_unp_size <<= 8; file_hdr_unp_size += file_hdr_block[11];

		if (verbose) {
			fprintf(stderr, "! HEAD_SIZE: %d, PACK_SIZE: %"PRIu64
			        ", UNP_SIZE: %"PRIu64"\n",
			        file_hdr_head_size,
			        (uint64_t)file_hdr_pack_size,
			        (uint64_t)file_hdr_unp_size);
			fprintf(stderr, "! file_hdr_block:\n!  ");
			for (i = 0; i < 32; ++i)
				fprintf(stderr, " %02x", file_hdr_block[i]);
			fprintf(stderr, "\n");
		}
		/* calculate EXT_TIME size */
		ext_time_size = file_hdr_head_size - 32;

		if (file_hdr_head_flags & 0x100) {
			uint64_t ex;
			if (fread(rejbuf, 4, 1, fp) != 1) {
				fprintf(stderr, "\n! %s: Error: read failed: %s.\n",
					archive_name, strerror(errno));
				goto err;
			}
			if (verbose) {
				fprintf(stderr, "!  ");
				for (i = 0; i < 4; ++i)
					fprintf(stderr, " %02x", rejbuf[i]);
			}
			ex = rejbuf[3];
			ex <<= 8; ex += rejbuf[2];
			ex <<= 8; ex += rejbuf[1];
			ex <<= 8; ex += rejbuf[0];
			ex <<= 32;
			file_hdr_pack_size += ex;
			ext_time_size -= 4;

			if (fread(rejbuf, 4, 1, fp) != 1) {
				fprintf(stderr, "\n! %s: Error: read failed: %s.\n",
					archive_name, strerror(errno));
				goto err;
			}
			if (verbose) {
				for (i = 0; i < 4; ++i)
					fprintf(stderr, " %02x", rejbuf[i]);
				fprintf(stderr, "   (High Pack/Unp extra header data)\n");
			}
			ex = rejbuf[3];
			ex <<= 8; ex += rejbuf[2];
			ex <<= 8; ex += rejbuf[1];
			ex <<= 8; ex += rejbuf[0];
			ex <<= 32;
			file_hdr_unp_size += ex;
			ext_time_size -= 4;
			if (verbose) {
				fprintf(stderr, "! HIGH_PACK_SIZE present\n");
				fprintf(stderr, "! HIGH_UNP_SIZE present\n");
				if (sizeof(size_t) < 8) {
					fprintf(stderr, "! %s: Error: File contains 64-bit sizes "
					        "but this build of %s doesn't support it.\n",
					        archive_name, self_name);
					goto err;
				}
			}
		}

		/* file name processing */
		file_name_size =
		    file_hdr_block[27] << 8 | file_hdr_block[26];
		if (verbose) {
			fprintf(stderr, "! file name size: %d bytes\n", file_name_size);
		}
		memset(file_name, 0, sizeof(file_name));

		if (!check_fread(sizeof(file_name), file_name_size, 1))
			goto err;
		if (fread(file_name, file_name_size, 1, fp) != 1) {
			fprintf(stderr, "! %s: Error: read failed: %s.\n",
				archive_name, strerror(errno));
			goto err;
		}

		file_name[sizeof(file_name) - 1] = 0;
		ext_time_size -= file_name_size;

		/* If this flag is set, file_name contains some weird
		   wide char encoding that need to be decoded to UTF16
		   and then to UTF-8 (we don't support codepages here) */
		if (file_hdr_head_flags & 0x200) {
			UTF16 FileNameW[PATH_BUF_SIZE];
			int Length = strlen((char*)file_name);

			if (verbose) {
				hexdump("! Encoded filenames", file_name, file_name_size);
			}
			DecodeFileName(file_name, file_name + Length + 1,
			                sizeof(file_name) - Length - 1,
			               FileNameW, sizeof(FileNameW));

			if (*FileNameW) {
				if (verbose) {
					hexdump("! UTF16 filename", FileNameW,
					               strlen16(FileNameW) << 1);
					fprintf(stderr, "OEM name:  %s\n", file_name);
				}
				utf16_to_utf8_r(file_name, PATH_BUF_SIZE, FileNameW);
				fprintf(stderr, "! Unicode:   %s\n", file_name);
			} else
				fprintf(stderr, "! UTF8 name: %s\n", file_name);
		}
        else
			fprintf(stderr, "! file name: %s\n", file_name);

		/* We duplicate file names to the GECOS field, for single mode */
		if (gecos_len + strlen((char*)file_name) < LINE_BUFFER_SIZE)
			gecos_len += snprintf(&gecos[gecos_len], LINE_BUFFER_SIZE - gecos_len - 1, "%s ", (char*)file_name);

		/* salt processing */
		if (file_hdr_head_flags & 0x400) {
			ext_time_size -= 8;
			if (fread(salt, 8, 1, fp) != 1) {
				fprintf(stderr, "! %s: Error: read failed: %s.\n",
					archive_name, strerror(errno));
				goto err;
			}

		}

		/* EXT_TIME processing */
		if (file_hdr_head_flags & 0x1000) {
			if (verbose) {
				fprintf(stderr, "! EXT_TIME present with size %d\n",
				        ext_time_size);
			}

			if (!check_fread(sizeof(rejbuf), ext_time_size, 1))
				goto err;

			if (fread(rejbuf, ext_time_size, 1, fp) != 1) {
				fprintf(stderr, "! %s: Error: read failed: %s.\n",
					archive_name, strerror(errno));
				goto err;
			}
		}

		/* Skip solid files (first file is never solid)
		 * We could probably add support for this
		 */
		if (file_hdr_head_flags & 0x10) {
			fprintf(stderr, "! Solid, can't handle (currently)\n");
			jtr_fseek64(fp, file_hdr_pack_size, SEEK_CUR);
			goto next_file_header;
		}

		if ((file_hdr_head_flags & 0xe0)>>5 == 7) {
			if (verbose) {
				fprintf(stderr, "! Is a directory, skipping\n");
			}
			jtr_fseek64(fp, file_hdr_pack_size, SEEK_CUR);
			goto next_file_header;
		}
		else if (verbose) {
			fprintf(stderr, "! Dictionary size: %u KB\n", 64<<((file_hdr_head_flags & 0xe0)>>5));
		}

		/* Check if encryption is being used */
		if (!(file_hdr_head_flags & 0x04)) {
			fprintf(stderr, "! not encrypted, skipping\n");
			jtr_fseek64(fp, file_hdr_pack_size, SEEK_CUR);
			goto next_file_header;
		} else if (file_hdr_block[24] < 29) {
			fprintf(stderr, "! %s: Too old RAR file version (v%u.%u encryption), not supported.\n",
			        archive_name, file_hdr_block[24] / 10, file_hdr_block[24] % 10);
			jtr_fseek64(fp, file_hdr_pack_size, SEEK_CUR);
			goto next_file_header;
		}


		method = file_hdr_block[25];

		/*
		 * Prefer shortest pack size, but given two files with single-block
		 * pack size, prefer unpack size >= 8. This gives us better immunity
		 * against false positives.
		 */
		if (bestsize.pack < SIZE_MAX &&
		    (((bestsize.pack < file_hdr_pack_size &&
		       bestsize.unp >= (bestsize.method > 0x30 ? 4 : 1)) ||
		      (bestsize.unp > file_hdr_unp_size &&
		       file_hdr_unp_size < (method > 0x30 ? 4 : 1))) ||
		     (bestsize.pack == file_hdr_pack_size &&
		      ((bestsize.unp > file_hdr_unp_size && file_hdr_unp_size < 8) ||
		       (bestsize.unp <= file_hdr_unp_size && bestsize.unp >= 8))))) {
			if (verbose)
				fprintf(stderr,
				        "! We got a better candidate already, skipping\n");
			jtr_fseek64(fp, file_hdr_pack_size, SEEK_CUR);
			goto next_file_header;
		}

		if (verbose)
			fprintf(stderr, "! This is best candidate so far\n");
		bestsize.pack = file_hdr_pack_size;
		bestsize.unp = file_hdr_unp_size;
		bestsize.method = method;

		free(best);
		best = calloc(1, 2 * LINE_BUFFER_SIZE + 2 * file_hdr_pack_size);

		/* process encrypted data of size "file_hdr_pack_size" */
		best_len = sprintf(best, "%s:$RAR3$*%d*", base_aname, type);
		for (i = 0; i < 8; i++) { /* encode salt */
			best_len += sprintf(&best[best_len], "%c%c", itoa16[ARCH_INDEX(salt[i] >> 4)], itoa16[ARCH_INDEX(salt[i] & 0x0f)]);
		}
		if (verbose) {
			fprintf(stderr, "! salt: '%s'\n", best);
		}
		best_len += sprintf(&best[best_len], "*");
		memcpy(file_crc, file_hdr_block + 16, 4);
		for (i = 0; i < 4; i++) { /* encode file_crc */
			best_len += sprintf(&best[best_len], "%c%c", itoa16[ARCH_INDEX(file_crc[i] >> 4)], itoa16[ARCH_INDEX(file_crc[i] & 0x0f)]);
		}
		if (verbose) {
			/* Minimal version needed to unpack this file */
			fprintf(stderr, "! UNP_VER is %0.1f\n", (float)file_hdr_block[24] / 10.);
		}
		/*
		 * 0x30 - storing
		 * 0x31 - fastest compression
		 * 0x32 - fast compression
		 * 0x33 - normal compression (default)
		 * 0x34 - good compression
		 * 0x35 - best compression
		 *
		 * m3b means 0x33 and a dictionary size of 128KB (a == 64KB .. g == 4096KB)
		 */
		if (verbose) {
			fprintf(stderr, "! METHOD is m%x%c\n", method - 0x30, 'a'+((file_hdr_head_flags&0xe0)>>5));
			//fprintf(stderr, "! file_hdr_flags is 0x%04x\n", file_hdr_head_flags);
		}

		best_len += sprintf(&best[best_len], "*%"PRIu64"*%"PRIu64"*",
		        (uint64_t)file_hdr_pack_size,
		        (uint64_t)file_hdr_unp_size);

		/* We always store it inline */

		best_len += sprintf(&best[best_len], "1*");
		p = &best[best_len];
		bytes_left = file_hdr_pack_size;
		for (i = 0; i < file_hdr_pack_size; i++) {
			unsigned char bytes[64*1024];
			unsigned x, to_read = 64*1024;
			if (bytes_left < 64*1024)
				to_read = bytes_left;
			bytes_left -= to_read;
			if (fread(bytes, 1, to_read, fp) != to_read)
				fprintf(stderr, "! Error while reading archive: %s\n", strerror(errno));
			for (x = 0; x < to_read; ++x) {
				s = bytes[x];
				*p++ = itoa16[s >> 4];
				*p++ = itoa16[s & 0xf];
			}
		}
		best_len += file_hdr_pack_size;
		best_len += sprintf(p, "*%02x:%d::", method, type);

		/* Keep looking for better candidates */
		goto next_file_header;

BailOut:
		if (best && *best) {
			if (verbose) {
				fprintf(stderr, "! Found a valid -p mode candidate in %s\n", base_aname);
			}
			if (bestsize.unp < (bestsize.method > 0x30 ? 5 : 1))
				fprintf(stderr, "! WARNING best candidate found is too small, you may see false positives.\n");
			strncat(best, gecos, LINE_BUFFER_SIZE - best_len - 1);
			puts(best);
		} else
			fprintf(stderr, "! Did not find a valid encrypted candidate in %s\n", base_aname);
	}

err:
	if (fp)
		fclose(fp);
	free(best);
	free(gecos);
}


/**************************************************************************
 * Here are the functions and tools for RAR5
 *************************************************************************/

// global variables
static int Encrypted = 0;
static unsigned char PswCheck[SIZE_PSWCHECK];
static unsigned rar5_interations=0, UsePswCheck=0;
static unsigned char rar5_salt[SIZE_SALT50];

/**************************************************************************
 * These 4 functions do much of the reading for rar5 files. There is a
 * function to read a 4 byte int (in LE format), one to read a single
 * byte, one to to read a buffer, and one that reads the variable sized
 * numbers used in rar5 (LE format, 7 bits used per byte with high bit
 * used to signify if there are more bytes of data or not)
 *************************************************************************/
int read_uint32 (FILE *fp, uint32_t *n, uint32_t *bytes_read) {
	unsigned char Buf[4];
	int i, shift=0;
	*n = 0;
	if (fread(Buf, 1, 4, fp) < 4)
		return 0;
	for (i = 0; i < 4; ++i) {
		*n  = *n + (Buf[i] << shift);
		shift += 8;
	}
    *bytes_read += 4;
	return 4;
}
int read_uint8 (FILE *fp, uint8_t *n, uint32_t *bytes_read) {
	unsigned char Buf[1];
	if (fread(Buf, 1, 1, fp) < 1)
		return 0;
    *n = Buf[0];
    *bytes_read += 1;
	return 1;
}
int read_buf (FILE *fp, unsigned char *cp, int len, uint32_t *bytes_read) {
	if (fread(cp, 1, len, fp) < 1)
		return 0;
    *bytes_read += len;
	return len;
}
int read_vuint (FILE *fp, uint64_t *n, uint32_t *bytes_read) {
	unsigned char c;
	int i, shift=0;
    uint64_t accum;
	*n = 0;
	for (i = 0; i < 10; ++i) {
		if (fread(&c, 1, 1, fp) != 1)
			return 0;
        accum = (c&0x7f);
		*n = *n + (accum << shift);
		shift += 7;
		if ((c & 0x80) == 0) {
            *bytes_read += i+1;
			return i+1;
		}
	}
	return 0;
}

/**************************************************************************
 * Process an 'extra' block of data. This is where rar5 stores the
 * encryption block.
 *************************************************************************/
static int ProcessExtra50(FILE *fp, uint64_t extra_size, uint64_t HeadSize, uint32_t HeaderType, uint32_t CurBlockPos, const char *archive_name, int *found)
{
	uint64_t FieldSize, FieldType, EncVersion, Flags;
	uint32_t bytes_read=0;
	int bytes_left=(int)extra_size;
	unsigned char Lg2Count;
	char *base_aname = basename(archive_name);

   // fprintf(stderr, "in extra50 extrasize=%d\n", extra_size);
    while (1) {
        int len = read_vuint(fp, &FieldSize, &bytes_read);
        if (!len || len > 3) return 0;  // rar5 technote (http://www.rarlab.com/technote.htm#arcblocks) lists max size of header len is 3 byte vint.
        bytes_left -= len;
        bytes_left -= (uint32_t)FieldSize;
        if (bytes_left < 0) return 0;
        if (!read_vuint(fp, &FieldType, &bytes_read)) return 0;
        // fprintf(stderr, "in Extra50.  FieldSize=%d FieldType=%d\n", FieldSize, FieldType);
        if (HeaderType == HEAD_FILE || HeaderType == HEAD_SERVICE) {
            if (FieldType == FHEXTRA_CRYPT) {
                unsigned char InitV[SIZE_INITV];
                unsigned char Hex1[128], Hex2[128], Hex3[128];
                if (!read_vuint(fp, &EncVersion, &bytes_read)) return 0;
                if (!read_vuint(fp, &Flags, &bytes_read)) return 0;
                if ( (Flags & FHEXTRA_CRYPT_PSWCHECK) == 0) {
                    fprintf(stderr, "UsePswCheck is OFF. We currently don't support such files!\n");
                    return 0;
                }
                if (!read_uint8(fp, &Lg2Count, &bytes_read)) return 0;
                if (Lg2Count >= CRYPT5_KDF_LG2_COUNT_MAX) {
                    fprintf(stderr, "Lg2Count >= CRYPT5_KDF_LG2_COUNT_MAX (problem with file?)");
                    return 0;
                }
                if (!read_buf(fp, rar5_salt, SIZE_SALT50, &bytes_read)) return 0;
                if (!read_buf(fp, InitV, SIZE_INITV, &bytes_read)) return 0;
                if (!read_buf(fp, PswCheck, SIZE_PSWCHECK, &bytes_read)) return 0;
                (*found)++;
                printf("%s:$rar5$%d$%s$%d$%s$%d$%s\n",
                    base_aname,
                    SIZE_SALT50, base64_convert_cp(rar5_salt,e_b64_raw,SIZE_SALT50,Hex1,e_b64_hex,sizeof(Hex1),0, 0),
                    Lg2Count, base64_convert_cp(InitV,e_b64_raw,SIZE_INITV,Hex2,e_b64_hex,sizeof(Hex2),0, 0),
                    SIZE_PSWCHECK, base64_convert_cp(PswCheck,e_b64_raw,SIZE_PSWCHECK,Hex3,e_b64_hex,sizeof(Hex3),0, 0));
                return 0;
            }
        }
    }
    return 1;
 }

/**************************************************************************
 * Common file header processing for rar5
 *************************************************************************/

static size_t read_rar5_header(FILE *fp, size_t CurBlockPos, uint8_t *HeaderType, const char *archive_name, int *found)
{
	uint64_t block_size, flags, extra_size=0, data_size=0;
	uint64_t crypt_version, enc_flags, HeadSize;
	uint32_t head_crc, header_bytes_read = 0, sizeof_vint;
	uint8_t header_type, lg_2count;
	char *base_aname = basename(archive_name);

    if (Encrypted) {
        // The header is encrypted, so we simply find the IV from this block.
        unsigned char HeadersInitV[SIZE_INITV];
        unsigned char Hex1[128], Hex2[128], Hex3[128];
        sizeof_vint = read_buf(fp, HeadersInitV,  SIZE_INITV, &header_bytes_read);
        if (sizeof_vint != SIZE_INITV) {
            fprintf(stderr, "Error, rar file %s too short, could not read IV from header\n", archive_name);
            return 0;
        }
        (*found)++;
        printf("%s:$rar5$%d$%s$%d$%s$%d$%s\n",
            base_aname,
            SIZE_SALT50, base64_convert_cp(rar5_salt,e_b64_raw,SIZE_SALT50,Hex1,e_b64_hex,sizeof(Hex1),0, 0),
            rar5_interations, base64_convert_cp(HeadersInitV,e_b64_raw,SIZE_INITV,Hex2,e_b64_hex,sizeof(Hex2),0, 0),
            SIZE_PSWCHECK, base64_convert_cp(PswCheck,e_b64_raw,SIZE_PSWCHECK,Hex3,e_b64_hex,sizeof(Hex3),0, 0));
        return 0;
    }
	if (!read_uint32(fp, &head_crc, &header_bytes_read)) return 0;

    sizeof_vint = read_vuint(fp, &block_size, &header_bytes_read);
    if (!sizeof_vint) return 0;
    // The HeadSize is full size of this header from the start of the HeaderCRC, to the end of any 'extra-data' section.
    HeadSize = block_size + 4 + sizeof_vint;

	//if (!read_vuint(fp, &header_type, &header_bytes_read)) return 0;
    if (!read_uint8(fp, &header_type, &header_bytes_read)) return 0;
    if (!read_vuint(fp, &flags, &header_bytes_read)) return 0;
    *HeaderType = header_type;
    if ((flags & HFL_EXTRA) != 0) { if (!read_vuint(fp, &extra_size, &header_bytes_read)) return 0; }
    if ((flags & HFL_DATA) != 0)  { if (!read_vuint(fp, &data_size, &header_bytes_read)) return 0; }

    // fprintf(stderr, "curpos=%d bs=%d firstreadsize=%d, sizeBytes=%d headtye=%d flags=%d \n", NowCurPos, block_size, 7, SizeBytes, header_type, flags);

    if (header_type == HEAD_CRYPT) {
       unsigned char chksum[SIZE_PSWCHECK_CSUM];
       if (!read_vuint(fp, &crypt_version, &header_bytes_read)) return 0;
       if (crypt_version > CRYPT_VERSION) { printf("bad rar crypt version byte\n"); return 0; }
       if (!read_vuint(fp, &enc_flags, &header_bytes_read)) return 0;
       UsePswCheck = (enc_flags & CHFL_CRYPT_PSWCHECK) != 0;  // set global
       if (!read_uint8(fp, &lg_2count, &header_bytes_read)) return 0;
       if (lg_2count > CRYPT5_KDF_LG2_COUNT_MAX) { printf("rar PBKDF2 iteration count too large\n"); return 0; }
       rar5_interations = lg_2count; // set global
       // get salt
       if (!read_buf(fp, rar5_salt, SIZE_SALT50, &header_bytes_read)) return 0;
       if (UsePswCheck) {
           unsigned char sha256ch[32];
           SHA256_CTX ctx;
           if (!read_buf(fp, PswCheck, SIZE_PSWCHECK, &header_bytes_read)) return 0;
           if (!read_buf(fp, chksum, SIZE_PSWCHECK_CSUM, &header_bytes_read)) return 0;
           SHA256_Init(&ctx);
		   SHA256_Update(&ctx, PswCheck, SIZE_PSWCHECK);
		   SHA256_Final(sha256ch, &ctx);
           UsePswCheck = !memcmp(sha256ch, chksum, sizeof(chksum));
       }
       Encrypted = 1;
     } else if (header_type == HEAD_MAIN) {
        uint64_t ArcFlags, VolNumber=0;
        if (!read_vuint(fp, &ArcFlags, &header_bytes_read)) return 0;
        if ((ArcFlags & MHFL_VOLNUMBER) != 0)
            if (!read_vuint(fp, &VolNumber, &header_bytes_read)) return 0;
    } else if (header_type == HEAD_FILE || header_type == HEAD_SERVICE) {
        uint64_t FileFlags, UnpSize, FileAttr;
        uint64_t CompInfo, HostOS, NameSize;
        uint32_t FileHashCRC32, tmp;

        if (!read_vuint(fp, &FileFlags, &header_bytes_read)) return 0;
        if (!read_vuint(fp, &UnpSize, &header_bytes_read)) return 0;
        if (!read_vuint(fp, &FileAttr, &header_bytes_read)) return 0;

        if ((FileFlags & FHFL_UTIME) != 0) {
            if (!read_uint32(fp, &tmp, &header_bytes_read)) return 0;
            //mtime = tmp;
        }

        if ((FileFlags & FHFL_CRC32) != 0) {
            if (!read_uint32(fp, &FileHashCRC32, &header_bytes_read)) return 0;
        }

        if (!read_vuint(fp, &CompInfo, &header_bytes_read)) return 0;
        if (!read_vuint(fp, &HostOS, &header_bytes_read)) return 0;
        if (!read_vuint(fp, &NameSize, &header_bytes_read)) return 0;
        // skip the field name.
        jtr_fseek64(fp, NameSize, SEEK_CUR);
        if (extra_size != 0)
	        ProcessExtra50(fp, extra_size, HeadSize, *HeaderType, CurBlockPos, archive_name, found);

    } else if (header_type == HEAD_ENDARC) {
        return 0;
    }
	return CurBlockPos+HeadSize+data_size;
}

/* handle rar5 files */
static int process_file5(const char *archive_name) {
	unsigned char Magic[RAR5_MAGIC_SIZE], buf[CHUNK_SIZE], *pos;
	size_t count, NextBlockPos, CurBlockPos;
	int diff, found = 0;
	FILE *fp;

	if (!(fp = fopen(archive_name, "rb"))) {
		fprintf(stderr, "! %s: %s\n", archive_name, strerror(errno));
		return 0;
	}

	if (fread(Magic, sizeof(Magic), 1, fp) != 1) {
		fprintf(stderr, "! %s: Not a RAR file\n", archive_name);
		goto err;
	}

	if (memcmp(Magic, "MZ", 2) == 0) {
		/* Handle SFX archive, find "Rar!" signature */
		while (!feof(fp)) {
			count = fread(buf, 1, CHUNK_SIZE, fp);
			if (count < RAR5_MAGIC_SIZE)
				break;
			if ((pos = memmem(buf, count, RAR5_MAGIC, RAR5_MAGIC_SIZE))) {
				diff = count - (pos - buf);
				jtr_fseek64(fp, - diff, SEEK_CUR);
				jtr_fseek64(fp, RAR5_MAGIC_SIZE, SEEK_CUR);
				found = 1;
				break;
			}
			if (feof(fp)) /* We should examine the EOF before seek back */
				break;
			jtr_fseek64(fp, 1 - RAR5_MAGIC_SIZE, SEEK_CUR);
		}
	}

	if (memcmp(Magic, RAR5_MAGIC, RAR5_MAGIC_SIZE) && !found) {
		fprintf(stderr, "! %s: Not a RAR file\n", archive_name);
		goto err;
	}

	found = 0;
	while (1) {
		uint8_t HeaderType;

		CurBlockPos = (size_t)jtr_ftell64(fp);
		NextBlockPos = read_rar5_header(fp, CurBlockPos, &HeaderType, archive_name, &found);
		if (!NextBlockPos)
			break;
		// fprintf(stderr, "NextBlockPos is %d Headertype=%d curblockpos=%d\n", NextBlockPos, HeaderType, CurBlockPos);
		jtr_fseek64(fp, NextBlockPos, SEEK_SET);
	}

	if (fp) fclose(fp);
	if (!found)
		fprintf(stderr, "! Did not find a valid encrypted candidate in %s\n", archive_name);

	return 1;

err:
	if (fp) fclose(fp);
	return 0;
}


static int usage(char *name)
{
	fprintf(stderr,"Usage: %s <rar file(s)>\n", name);
	return EXIT_FAILURE;
}

int main(int argc, char **argv)
{
	int c;

	self_name = argv[0];

	/* Parse command line */
	while ((c = getopt(argc, argv, "v")) != -1) {
		switch (c) {
		case 'v':
			verbose = 1;
			break;
		case '?':
		default:
			return usage(argv[0]);
		}
	}
	argc -= optind;
	if (argc == 0)
		return usage(argv[0]);
	argv += optind;

	while (argc--)
		process_file(*argv++);

	return EXIT_SUCCESS;
}
